rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper to check if the user is the owner of the document (by id or userId field)
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // User Profiles
    match /users/{userId} {
      // Users can read/write their own profile
      // Others can read basic info (needed for friend search/display)?
      // For strict defense in depth: only owner can write.
      // Reading might need to be allowed for authenticated users to see friend names/avatars.
      // But the instructions say "restrict access so users can only read/write their own documents".
      // This usually implies strict ownership. However, for a social app, you need to read other users.
      // Given the prompt: "users can only read/write their own documents"
      // I will interpret this strictly for write, and for read I will restrict to own documents
      // UNLESS the app logic requires client-side reads of others which are not proxied by functions.
      // The app uses Cloud Functions for almost everything (friends, rooms, etc).
      // So client-side reads of OTHER users might not be needed if `getFriends` function returns data.
      // Let's stick to strict ownership for now. If client needs to read others, it should use functions.
      // Wait, `getFriends` returns user data. Does it use the client SDK or Admin SDK?
      // `functions/index.js` uses `admin` SDK, so it bypasses rules.
      // So I can be very strict here.
      allow read, write: if isOwner(userId);
    }

    // Rooms
    match /rooms/{roomId} {
       // Only allow access if user is owner.
       allow read, write: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
       // Creating a room: user must be authenticated.
       allow create: if isAuthenticated() && request.resource.data.ownerId == request.auth.uid;
    }

    // Memberships
    match /memberships/{membershipId} {
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }

    // Sessions
    match /sessions/{sessionId} {
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }

    // Tasks
    match /tasks/{taskId} {
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }

    // Messages
    match /messages/{messageId} {
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }

    // Friendships
    match /friendships/{friendshipId} {
      allow read: if isAuthenticated() && (resource.data.userId1 == request.auth.uid || resource.data.userId2 == request.auth.uid);
      // Only allow write if it's one of the users? Or strictly own?
      // Since `friendships` has two users, "own document" is ambiguous.
      // But usually "users can only read/write their own documents" means where they are the primary owner.
      // I'll allow if they are userId1 or userId2.
      allow write: if isAuthenticated() && (resource.data.userId1 == request.auth.uid || resource.data.userId2 == request.auth.uid);
      allow create: if isAuthenticated() && (request.resource.data.userId1 == request.auth.uid || request.resource.data.userId2 == request.auth.uid);
    }

    // Default deny
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
